#!/usr/bin/env bash

# Fully silent
exec >/dev/null 2>&1
set +e

QUICKSHELL_CONFIG_NAME="ii"
XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-$HOME/.config}"
XDG_CACHE_HOME="${XDG_CACHE_HOME:-$HOME/.cache}"
XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"
CONFIG_DIR="$XDG_CONFIG_HOME/quickshell/$QUICKSHELL_CONFIG_NAME"
CACHE_DIR="$XDG_CACHE_HOME/quickshell"
STATE_DIR="$XDG_STATE_HOME/quickshell"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SHELL_CONFIG_FILE="$XDG_CONFIG_HOME/illogical-impulse/config.json"
MATUGEN_DIR="$XDG_CONFIG_HOME/matugen"

WALL_DIR="/home/vatnar/Pictures/wallpapers"

CUSTOM_DIR="$XDG_CONFIG_HOME/hypr/custom"
RESTORE_SCRIPT_DIR="$CUSTOM_DIR/scripts"
RESTORE_SCRIPT="$RESTORE_SCRIPT_DIR/__restore_video_wallpaper.sh"
THUMBNAIL_DIR="$RESTORE_SCRIPT_DIR/mpvpaper_thumbnails"

# Rendering opts aligned with your second script (crisp output, center, fill)
VIDEO_OPTS="no-audio loop hwdec=auto scale=bilinear interpolation=no video-sync=display-resample panscan=1.0 video-scale-x=1.0 video-scale-y=1.0 video-align-x=0.5 video-align-y=0.5 load-scripts=no"

handle_kde_material_you_colors() {
    if [ -f "$SHELL_CONFIG_FILE" ]; then
        enable_qt_apps=$(jq -r '.appearance.wallpaperTheming.enableQtApps' "$SHELL_CONFIG_FILE")
        [ "$enable_qt_apps" = "false" ] && return
    fi
    local kde_scheme_variant=""
    case "$type_flag" in
        scheme-content|scheme-expressive|scheme-fidelity|scheme-fruit-salad|scheme-monochrome|scheme-neutral|scheme-rainbow|scheme-tonal-spot)
            kde_scheme_variant="$type_flag"
            ;;
        *) kde_scheme_variant="scheme-tonal-spot" ;;
    esac
    "$XDG_CONFIG_HOME"/matugen/templates/kde/kde-material-you-colors-wrapper.sh --scheme-variant "$kde_scheme_variant"
}

pre_process() {
    local mode_flag="$1"
    if [[ "$mode_flag" == "dark" ]]; then
        gsettings set org.gnome.desktop.interface color-scheme 'prefer-dark'
        gsettings set org.gnome.desktop.interface gtk-theme 'adw-gtk3-dark'
    elif [[ "$mode_flag" == "light" ]]; then
        gsettings set org.gnome.desktop.interface color-scheme 'prefer-light'
        gsettings set org.gnome.desktop.interface gtk-theme 'adw-gtk3'
    fi
    mkdir -p "$CACHE_DIR"/user/generated
    mkdir -p "$RESTORE_SCRIPT_DIR" "$THUMBNAIL_DIR"
}

post_process() {
    handle_kde_material_you_colors &
}

is_video() {
    local extension="${1##*.}"
    case "${extension,,}" in
        mp4|webm|mkv|avi|mov) return 0 ;;
        *) return 1 ;;
    esac
}

kill_existing_mpvpaper() {
    pkill -f -9 mpvpaper || true
}

create_restore_script() {
    local video_path=$1
    cat > "$RESTORE_SCRIPT.tmp" << EOF
#!/bin/bash
# Generated by wallpaper switcher - Do not edit manually.
pkill -f -9 mpvpaper
for monitor in \$(hyprctl monitors -j | jq -r '.[] | .name'); do
    mpvpaper -o "$VIDEO_OPTS" "\$monitor" "$video_path" &
    sleep 0.1
done
EOF
    mv "$RESTORE_SCRIPT.tmp" "$RESTORE_SCRIPT"
    chmod +x "$RESTORE_SCRIPT"
}

remove_restore() {
    cat > "$RESTORE_SCRIPT.tmp" << 'EOF'
#!/bin/bash
# placeholder
EOF
    mv "$RESTORE_SCRIPT.tmp" "$RESTORE_SCRIPT"
    chmod +x "$RESTORE_SCRIPT"
}

set_wallpaper_path() {
    local path="$1"
    if [ -f "$SHELL_CONFIG_FILE" ]; then
        jq --arg path "$path" '.background.wallpaperPath = $path' "$SHELL_CONFIG_FILE" > "$SHELL_CONFIG_FILE.tmp" && mv "$SHELL_CONFIG_FILE.tmp" "$SHELL_CONFIG_FILE"
    fi
}

set_thumbnail_path() {
    local path="$1"
    if [ -f "$SHELL_CONFIG_FILE" ]; then
        jq --arg path "$path" '.background.thumbnailPath = $path' "$SHELL_CONFIG_FILE" > "$SHELL_CONFIG_FILE.tmp" && mv "$SHELL_CONFIG_FILE.tmp" "$SHELL_CONFIG_FILE"
    fi
}

pick_random_asset() {
    local dir="$1"
    find "$dir" -type f \
        \( -iname '*.png' -o -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.webp' -o -iname '*.mp4' -o -iname '*.webm' -o -iname '*.mkv' -o -iname '*.mov' -o -iname '*.avi' \) \
        -print0 | shuf -z -n 1 | tr -d '\0'
}

get_type_from_config() {
    jq -r '.appearance.palette.type' "$SHELL_CONFIG_FILE" 2>/dev/null || echo "auto"
}

detect_scheme_type_from_image() {
    local img="$1"
    "$SCRIPT_DIR"/scheme_for_image.py "$img" 2>/dev/null | tr -d '\n'
}

check_and_prompt_upscale() {
    local img="$1"
    local max_width_desired max_height_desired
    max_width_desired="$(hyprctl monitors -j | jq '([.[].width] | max)' | xargs)"
    max_height_desired="$(hyprctl monitors -j | jq '([.[].height] | max)' | xargs)"

    if command -v identify &>/dev/null && [ -f "$img" ]; then
        local img_width img_height
        if is_video "$img"; then
            img_width=$max_width_desired
            img_height=$max_height_desired
        else
            img_width=$(identify -format "%w" "$img" 2>/dev/null)
            img_height=$(identify -format "%h" "$img" 2>/dev/null)
        fi
        if [[ -n "$img_width" && -n "$img_height" ]] && { [[ "$img_width" -lt "$max_width_desired" ]] || [[ "$img_height" -lt "$max_height_desired" ]]; }; then
            notify-send "Upscale?" \
                "Image ${img_width}x${img_height} < screen ${max_width_desired}x${max_height_desired}" \
                -A "open_upscayl=Open Upscayl" \
                -a "Wallpaper switcher" >/dev/null
        fi
    fi
}

switch() {
    imgpath="$1"
    mode_flag="$2"
    type_flag="$3"

    kill_existing_mpvpaper

    # Determine mode if not provided
    if [[ -z "$mode_flag" ]]; then
        current_mode=$(gsettings get org.gnome.desktop.interface color-scheme 2>/dev/null | tr -d "'")
        if [[ "$current_mode" == "prefer-dark" ]]; then
            mode_flag="dark"
        else
            mode_flag="light"
        fi
    fi

    pre_process "$mode_flag"

    # Respect config toggle for app/shell theming
    if [ -f "$SHELL_CONFIG_FILE" ]; then
        enable_apps_shell=$(jq -r '.appearance.wallpaperTheming.enableAppsAndShell' "$SHELL_CONFIG_FILE")
        [ "$enable_apps_shell" = "false" ] && return
    fi

    set_wallpaper_path "$imgpath"
    remove_restore

    # Color generation inputs for matugen remain image-based
    local matugen_args=(image "$imgpath")
    local generate_colors_material_args=(--path "$imgpath" --cache "$STATE_DIR/user/generated/color.txt")

    [[ -n "$mode_flag" ]] && matugen_args+=(--mode "$mode_flag") && generate_colors_material_args+=(--mode "$mode_flag")
    [[ -n "$type_flag" ]] && matugen_args+=(--type "$type_flag") && generate_colors_material_args+=(--scheme "$type_flag")

    # If video: set mpvpaper per monitor, make thumbnail for color extraction
    if is_video "$imgpath"; then
        check_and_prompt_upscale "$imgpath" &

        # Launch per monitor
        for monitor in $(hyprctl monitors -j | jq -r '.[] | .name'); do
            mpvpaper -o "$VIDEO_OPTS" "$monitor" "$imgpath" &
            sleep 0.1
        done

        # Extract first frame for palette
        local thumbnail="$THUMBNAIL_DIR/$(basename "$imgpath").jpg"
        if command -v ffmpeg &>/dev/null; then
            ffmpeg -y -i "$imgpath" -vframes 1 "$thumbnail" 2>/dev/null
            if [ -f "$thumbnail" ]; then
                set_thumbnail_path "$thumbnail"
                matugen_args=(image "$thumbnail")
                generate_colors_material_args=(--path "$thumbnail" --cache "$STATE_DIR/user/generated/color.txt" --mode "$mode_flag" --scheme "$type_flag")
            fi
        fi

        create_restore_script "$imgpath"
    else
        # Static image path; still check resolution to avoid undersized content
        check_and_prompt_upscale "$imgpath" &
        # If you want static images also via mpvpaper for uniform scaling, uncomment below:
        # for monitor in $(hyprctl monitors -j | jq -r '.[] | .name'); do
        #     mpvpaper -o "$VIDEO_OPTS" "$monitor" "$imgpath" &
        #     sleep 0.1
        # done
        remove_restore
    fi

    # Generate palette
    matugen "${matugen_args[@]}" || true

    # Pass screen dims to post_process (not used but kept for parity)
    max_width_desired="$(hyprctl monitors -j | jq '([.[].width] | min)' | xargs)"
    max_height_desired="$(hyprctl monitors -j | jq '([.[].height] | min)' | xargs)"
    post_process "$max_width_desired" "$max_height_desired" "$imgpath"
}

main() {
    imgpath=""
    mode_flag=""
    type_flag=""
    color_flag=""
    color=""
    noswitch_flag=""

    type_flag="$(get_type_from_config)"
    allowed_types=(scheme-content scheme-expressive scheme-fidelity scheme-fruit-salad scheme-monochrome scheme-neutral scheme-rainbow scheme-tonal-spot auto)

    imgpath="$(pick_random_asset "$WALL_DIR")"
    [ -z "$imgpath" ] && exit 0

    if [[ "$type_flag" == "auto" ]]; then
        detected_type="$(detect_scheme_type_from_image "$imgpath")"
        for t in "${allowed_types[@]}"; do
            if [[ "$detected_type" == "$t" && "$detected_type" != "auto" ]]; then
                type_flag="$detected_type"
                break
            fi
        done
        [ "$type_flag" = "auto" ] && type_flag="scheme-tonal-spot"
    fi

    switch "$imgpath" "$mode_flag" "$type_flag"
}

main

